// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package traderepublic

import "encoding/json"
import "fmt"
import "reflect"
import "regexp"

type TimelineTransactionsSchemaJson struct {
	// Cursors corresponds to the JSON schema field "cursors".
	Cursors TimelineTransactionsSchemaJsonCursors `json:"cursors" yaml:"cursors" mapstructure:"cursors"`

	// Items corresponds to the JSON schema field "items".
	Items []TimelineTransactionsSchemaJsonItemsElem `json:"items" yaml:"items" mapstructure:"items"`

	// StartingTransactionId corresponds to the JSON schema field
	// "startingTransactionId".
	StartingTransactionId *string `json:"startingTransactionId,omitempty" yaml:"startingTransactionId,omitempty" mapstructure:"startingTransactionId,omitempty"`
}

type TimelineTransactionsSchemaJsonCursors struct {
	// After corresponds to the JSON schema field "after".
	After *string `json:"after" yaml:"after" mapstructure:"after"`

	// Before corresponds to the JSON schema field "before".
	Before string `json:"before" yaml:"before" mapstructure:"before"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TimelineTransactionsSchemaJsonCursors) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["after"]; raw != nil && !ok {
		return fmt.Errorf("field after in TimelineTransactionsSchemaJsonCursors: required")
	}
	if _, ok := raw["before"]; raw != nil && !ok {
		return fmt.Errorf("field before in TimelineTransactionsSchemaJsonCursors: required")
	}
	type Plain TimelineTransactionsSchemaJsonCursors
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = TimelineTransactionsSchemaJsonCursors(plain)
	return nil
}

type TimelineTransactionsSchemaJsonItemsElem struct {
	// Action corresponds to the JSON schema field "action".
	Action TimelineTransactionsSchemaJsonItemsElemAction `json:"action" yaml:"action" mapstructure:"action"`

	// Amount corresponds to the JSON schema field "amount".
	Amount TimelineTransactionsSchemaJsonItemsElemAmount `json:"amount" yaml:"amount" mapstructure:"amount"`

	// Avatar corresponds to the JSON schema field "avatar".
	Avatar TimelineTransactionsSchemaJsonItemsElemAvatar `json:"avatar" yaml:"avatar" mapstructure:"avatar"`

	// Badge corresponds to the JSON schema field "badge".
	Badge *string `json:"badge,omitempty" yaml:"badge,omitempty" mapstructure:"badge,omitempty"`

	// CashAccountNumber corresponds to the JSON schema field "cashAccountNumber".
	CashAccountNumber *string `json:"cashAccountNumber,omitempty" yaml:"cashAccountNumber,omitempty" mapstructure:"cashAccountNumber,omitempty"`

	// Deleted corresponds to the JSON schema field "deleted".
	Deleted bool `json:"deleted" yaml:"deleted" mapstructure:"deleted"`

	// EventType corresponds to the JSON schema field "eventType".
	EventType TimelineTransactionsSchemaJsonItemsElemEventType `json:"eventType" yaml:"eventType" mapstructure:"eventType"`

	// Hidden corresponds to the JSON schema field "hidden".
	Hidden bool `json:"hidden" yaml:"hidden" mapstructure:"hidden"`

	// Icon corresponds to the JSON schema field "icon".
	Icon string `json:"icon" yaml:"icon" mapstructure:"icon"`

	// Id corresponds to the JSON schema field "id".
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// Status corresponds to the JSON schema field "status".
	Status TimelineTransactionsSchemaJsonItemsElemStatus `json:"status" yaml:"status" mapstructure:"status"`

	// SubAmount corresponds to the JSON schema field "subAmount".
	SubAmount *TimelineTransactionsSchemaJsonItemsElemSubAmount `json:"subAmount,omitempty" yaml:"subAmount,omitempty" mapstructure:"subAmount,omitempty"`

	// Subtitle corresponds to the JSON schema field "subtitle".
	Subtitle *string `json:"subtitle,omitempty" yaml:"subtitle,omitempty" mapstructure:"subtitle,omitempty"`

	// Timestamp corresponds to the JSON schema field "timestamp".
	Timestamp string `json:"timestamp" yaml:"timestamp" mapstructure:"timestamp"`

	// Title corresponds to the JSON schema field "title".
	Title string `json:"title" yaml:"title" mapstructure:"title"`
}

type TimelineTransactionsSchemaJsonItemsElemAction struct {
	// Payload corresponds to the JSON schema field "payload".
	Payload string `json:"payload" yaml:"payload" mapstructure:"payload"`

	// Type corresponds to the JSON schema field "type".
	Type TimelineTransactionsSchemaJsonItemsElemActionType `json:"type" yaml:"type" mapstructure:"type"`
}

type TimelineTransactionsSchemaJsonItemsElemActionType string

const TimelineTransactionsSchemaJsonItemsElemActionTypeTimelineDetail TimelineTransactionsSchemaJsonItemsElemActionType = "timelineDetail"

var enumValues_TimelineTransactionsSchemaJsonItemsElemActionType = []interface{}{
	"timelineDetail",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TimelineTransactionsSchemaJsonItemsElemActionType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TimelineTransactionsSchemaJsonItemsElemActionType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TimelineTransactionsSchemaJsonItemsElemActionType, v)
	}
	*j = TimelineTransactionsSchemaJsonItemsElemActionType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TimelineTransactionsSchemaJsonItemsElemAction) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["payload"]; raw != nil && !ok {
		return fmt.Errorf("field payload in TimelineTransactionsSchemaJsonItemsElemAction: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in TimelineTransactionsSchemaJsonItemsElemAction: required")
	}
	type Plain TimelineTransactionsSchemaJsonItemsElemAction
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$`, string(plain.Payload)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "Payload", `^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$`)
	}
	*j = TimelineTransactionsSchemaJsonItemsElemAction(plain)
	return nil
}

type TimelineTransactionsSchemaJsonItemsElemAmount struct {
	// Currency corresponds to the JSON schema field "currency".
	Currency string `json:"currency" yaml:"currency" mapstructure:"currency"`

	// FractionDigits corresponds to the JSON schema field "fractionDigits".
	FractionDigits int `json:"fractionDigits" yaml:"fractionDigits" mapstructure:"fractionDigits"`

	// Value corresponds to the JSON schema field "value".
	Value float64 `json:"value" yaml:"value" mapstructure:"value"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TimelineTransactionsSchemaJsonItemsElemAmount) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["currency"]; raw != nil && !ok {
		return fmt.Errorf("field currency in TimelineTransactionsSchemaJsonItemsElemAmount: required")
	}
	if _, ok := raw["fractionDigits"]; raw != nil && !ok {
		return fmt.Errorf("field fractionDigits in TimelineTransactionsSchemaJsonItemsElemAmount: required")
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in TimelineTransactionsSchemaJsonItemsElemAmount: required")
	}
	type Plain TimelineTransactionsSchemaJsonItemsElemAmount
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^[A-Z]{3}$`, string(plain.Currency)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "Currency", `^[A-Z]{3}$`)
	}
	if 0 > plain.FractionDigits {
		return fmt.Errorf("field %s: must be >= %v", "fractionDigits", 0)
	}
	*j = TimelineTransactionsSchemaJsonItemsElemAmount(plain)
	return nil
}

type TimelineTransactionsSchemaJsonItemsElemAvatar struct {
	// Asset corresponds to the JSON schema field "asset".
	Asset string `json:"asset" yaml:"asset" mapstructure:"asset"`

	// Badge corresponds to the JSON schema field "badge".
	Badge *string `json:"badge,omitempty" yaml:"badge,omitempty" mapstructure:"badge,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TimelineTransactionsSchemaJsonItemsElemAvatar) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["asset"]; raw != nil && !ok {
		return fmt.Errorf("field asset in TimelineTransactionsSchemaJsonItemsElemAvatar: required")
	}
	type Plain TimelineTransactionsSchemaJsonItemsElemAvatar
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = TimelineTransactionsSchemaJsonItemsElemAvatar(plain)
	return nil
}

type TimelineTransactionsSchemaJsonItemsElemEventType string

const TimelineTransactionsSchemaJsonItemsElemEventTypeBenefitsSavebackExecution TimelineTransactionsSchemaJsonItemsElemEventType = "benefits_saveback_execution"
const TimelineTransactionsSchemaJsonItemsElemEventTypeBenefitsSpareChangeExecution TimelineTransactionsSchemaJsonItemsElemEventType = "benefits_spare_change_execution"
const TimelineTransactionsSchemaJsonItemsElemEventTypeCardFailedTransaction TimelineTransactionsSchemaJsonItemsElemEventType = "card_failed_transaction"
const TimelineTransactionsSchemaJsonItemsElemEventTypeCardFailedVerification TimelineTransactionsSchemaJsonItemsElemEventType = "card_failed_verification"
const TimelineTransactionsSchemaJsonItemsElemEventTypeCardRefund TimelineTransactionsSchemaJsonItemsElemEventType = "card_refund"
const TimelineTransactionsSchemaJsonItemsElemEventTypeCardSuccessfulTransaction TimelineTransactionsSchemaJsonItemsElemEventType = "card_successful_transaction"
const TimelineTransactionsSchemaJsonItemsElemEventTypeCardSuccessfulVerification TimelineTransactionsSchemaJsonItemsElemEventType = "card_successful_verification"
const TimelineTransactionsSchemaJsonItemsElemEventTypeINCOMINGTRANSFER TimelineTransactionsSchemaJsonItemsElemEventType = "INCOMING_TRANSFER"
const TimelineTransactionsSchemaJsonItemsElemEventTypeINCOMINGTRANSFERDELEGATION TimelineTransactionsSchemaJsonItemsElemEventType = "INCOMING_TRANSFER_DELEGATION"
const TimelineTransactionsSchemaJsonItemsElemEventTypeINTERESTPAYOUT TimelineTransactionsSchemaJsonItemsElemEventType = "INTEREST_PAYOUT"
const TimelineTransactionsSchemaJsonItemsElemEventTypeOUTGOINGTRANSFERDELEGATION TimelineTransactionsSchemaJsonItemsElemEventType = "OUTGOING_TRANSFER_DELEGATION"
const TimelineTransactionsSchemaJsonItemsElemEventTypeSspCorporateActionInvoiceCash TimelineTransactionsSchemaJsonItemsElemEventType = "ssp_corporate_action_invoice_cash"
const TimelineTransactionsSchemaJsonItemsElemEventTypeTimelineLegacyMigratedEvents TimelineTransactionsSchemaJsonItemsElemEventType = "timeline_legacy_migrated_events"
const TimelineTransactionsSchemaJsonItemsElemEventTypeTradingSavingsplanExecuted TimelineTransactionsSchemaJsonItemsElemEventType = "trading_savingsplan_executed"
const TimelineTransactionsSchemaJsonItemsElemEventTypeTradingTradeExecuted TimelineTransactionsSchemaJsonItemsElemEventType = "trading_trade_executed"

var enumValues_TimelineTransactionsSchemaJsonItemsElemEventType = []interface{}{
	"card_successful_transaction",
	"ssp_corporate_action_invoice_cash",
	"trading_savingsplan_executed",
	"benefits_saveback_execution",
	"card_failed_transaction",
	"INTEREST_PAYOUT",
	"INCOMING_TRANSFER_DELEGATION",
	"card_successful_verification",
	"card_failed_verification",
	"card_refund",
	"trading_trade_executed",
	"OUTGOING_TRANSFER_DELEGATION",
	"timeline_legacy_migrated_events",
	"INCOMING_TRANSFER",
	"benefits_spare_change_execution",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TimelineTransactionsSchemaJsonItemsElemEventType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TimelineTransactionsSchemaJsonItemsElemEventType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TimelineTransactionsSchemaJsonItemsElemEventType, v)
	}
	*j = TimelineTransactionsSchemaJsonItemsElemEventType(v)
	return nil
}

type TimelineTransactionsSchemaJsonItemsElemStatus string

const TimelineTransactionsSchemaJsonItemsElemStatusCANCELED TimelineTransactionsSchemaJsonItemsElemStatus = "CANCELED"
const TimelineTransactionsSchemaJsonItemsElemStatusEXECUTED TimelineTransactionsSchemaJsonItemsElemStatus = "EXECUTED"

var enumValues_TimelineTransactionsSchemaJsonItemsElemStatus = []interface{}{
	"EXECUTED",
	"CANCELED",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TimelineTransactionsSchemaJsonItemsElemStatus) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TimelineTransactionsSchemaJsonItemsElemStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TimelineTransactionsSchemaJsonItemsElemStatus, v)
	}
	*j = TimelineTransactionsSchemaJsonItemsElemStatus(v)
	return nil
}

type TimelineTransactionsSchemaJsonItemsElemSubAmount struct {
	// Currency corresponds to the JSON schema field "currency".
	Currency string `json:"currency" yaml:"currency" mapstructure:"currency"`

	// FractionDigits corresponds to the JSON schema field "fractionDigits".
	FractionDigits int `json:"fractionDigits" yaml:"fractionDigits" mapstructure:"fractionDigits"`

	// Value corresponds to the JSON schema field "value".
	Value float64 `json:"value" yaml:"value" mapstructure:"value"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TimelineTransactionsSchemaJsonItemsElemSubAmount) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["currency"]; raw != nil && !ok {
		return fmt.Errorf("field currency in TimelineTransactionsSchemaJsonItemsElemSubAmount: required")
	}
	if _, ok := raw["fractionDigits"]; raw != nil && !ok {
		return fmt.Errorf("field fractionDigits in TimelineTransactionsSchemaJsonItemsElemSubAmount: required")
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in TimelineTransactionsSchemaJsonItemsElemSubAmount: required")
	}
	type Plain TimelineTransactionsSchemaJsonItemsElemSubAmount
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^[A-Z]{3}$`, string(plain.Currency)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "Currency", `^[A-Z]{3}$`)
	}
	if 0 > plain.FractionDigits {
		return fmt.Errorf("field %s: must be >= %v", "fractionDigits", 0)
	}
	*j = TimelineTransactionsSchemaJsonItemsElemSubAmount(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TimelineTransactionsSchemaJsonItemsElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["action"]; raw != nil && !ok {
		return fmt.Errorf("field action in TimelineTransactionsSchemaJsonItemsElem: required")
	}
	if _, ok := raw["amount"]; raw != nil && !ok {
		return fmt.Errorf("field amount in TimelineTransactionsSchemaJsonItemsElem: required")
	}
	if _, ok := raw["avatar"]; raw != nil && !ok {
		return fmt.Errorf("field avatar in TimelineTransactionsSchemaJsonItemsElem: required")
	}
	if _, ok := raw["deleted"]; raw != nil && !ok {
		return fmt.Errorf("field deleted in TimelineTransactionsSchemaJsonItemsElem: required")
	}
	if _, ok := raw["eventType"]; raw != nil && !ok {
		return fmt.Errorf("field eventType in TimelineTransactionsSchemaJsonItemsElem: required")
	}
	if _, ok := raw["hidden"]; raw != nil && !ok {
		return fmt.Errorf("field hidden in TimelineTransactionsSchemaJsonItemsElem: required")
	}
	if _, ok := raw["icon"]; raw != nil && !ok {
		return fmt.Errorf("field icon in TimelineTransactionsSchemaJsonItemsElem: required")
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in TimelineTransactionsSchemaJsonItemsElem: required")
	}
	if _, ok := raw["status"]; raw != nil && !ok {
		return fmt.Errorf("field status in TimelineTransactionsSchemaJsonItemsElem: required")
	}
	if _, ok := raw["timestamp"]; raw != nil && !ok {
		return fmt.Errorf("field timestamp in TimelineTransactionsSchemaJsonItemsElem: required")
	}
	if _, ok := raw["title"]; raw != nil && !ok {
		return fmt.Errorf("field title in TimelineTransactionsSchemaJsonItemsElem: required")
	}
	type Plain TimelineTransactionsSchemaJsonItemsElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$`, string(plain.Id)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "Id", `^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$`)
	}
	*j = TimelineTransactionsSchemaJsonItemsElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TimelineTransactionsSchemaJson) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["cursors"]; raw != nil && !ok {
		return fmt.Errorf("field cursors in TimelineTransactionsSchemaJson: required")
	}
	if _, ok := raw["items"]; raw != nil && !ok {
		return fmt.Errorf("field items in TimelineTransactionsSchemaJson: required")
	}
	type Plain TimelineTransactionsSchemaJson
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = TimelineTransactionsSchemaJson(plain)
	return nil
}
