// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package traderepublic

import "encoding/json"
import "fmt"
import "reflect"

type WsResponseJson struct {
	// Data corresponds to the JSON schema field "Data".
	Data string `json:"Data" yaml:"Data" mapstructure:"Data"`

	// ID corresponds to the JSON schema field "ID".
	ID int `json:"ID" yaml:"ID" mapstructure:"ID"`

	// State corresponds to the JSON schema field "State".
	State WsResponseJsonState `json:"State" yaml:"State" mapstructure:"State"`
}

type WsResponseJsonState string

const WsResponseJsonStateA WsResponseJsonState = "A"
const WsResponseJsonStateC WsResponseJsonState = "C"
const WsResponseJsonStateE WsResponseJsonState = "E"

var enumValues_WsResponseJsonState = []interface{}{
	"A",
	"C",
	"E",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WsResponseJsonState) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_WsResponseJsonState {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_WsResponseJsonState, v)
	}
	*j = WsResponseJsonState(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WsResponseJson) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["Data"]; raw != nil && !ok {
		return fmt.Errorf("field Data in WsResponseJson: required")
	}
	if _, ok := raw["ID"]; raw != nil && !ok {
		return fmt.Errorf("field ID in WsResponseJson: required")
	}
	if _, ok := raw["State"]; raw != nil && !ok {
		return fmt.Errorf("field State in WsResponseJson: required")
	}
	type Plain WsResponseJson
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = WsResponseJson(plain)
	return nil
}
