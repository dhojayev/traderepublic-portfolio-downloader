// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package traderepublic

import "encoding/json"
import "fmt"
import "reflect"
import "regexp"

type Company struct {
	// CountryOfOrigin corresponds to the JSON schema field "countryOfOrigin".
	CountryOfOrigin *string `json:"countryOfOrigin,omitempty" yaml:"countryOfOrigin,omitempty" mapstructure:"countryOfOrigin,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Unix timestamp in milliseconds
	IpoDate *int `json:"ipoDate,omitempty" yaml:"ipoDate,omitempty" mapstructure:"ipoDate,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Company) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in Company: required")
	}
	type Plain Company
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.CountryOfOrigin != nil {
		if matched, _ := regexp.MatchString(`^[A-Z]{2}$`, string(*plain.CountryOfOrigin)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "CountryOfOrigin", `^[A-Z]{2}$`)
		}
	}
	*j = Company(plain)
	return nil
}

type Exchange struct {
	// Active corresponds to the JSON schema field "active".
	Active bool `json:"active" yaml:"active" mapstructure:"active"`

	// Band corresponds to the JSON schema field "band".
	Band *int `json:"band,omitempty" yaml:"band,omitempty" mapstructure:"band,omitempty"`

	// FirstSeen corresponds to the JSON schema field "firstSeen".
	FirstSeen *int `json:"firstSeen,omitempty" yaml:"firstSeen,omitempty" mapstructure:"firstSeen,omitempty"`

	// FractionalTrading corresponds to the JSON schema field "fractionalTrading".
	FractionalTrading *ExchangeFractionalTrading `json:"fractionalTrading,omitempty" yaml:"fractionalTrading,omitempty" mapstructure:"fractionalTrading,omitempty"`

	// LastSeen corresponds to the JSON schema field "lastSeen".
	LastSeen *int `json:"lastSeen,omitempty" yaml:"lastSeen,omitempty" mapstructure:"lastSeen,omitempty"`

	// NameAtExchange corresponds to the JSON schema field "nameAtExchange".
	NameAtExchange string `json:"nameAtExchange" yaml:"nameAtExchange" mapstructure:"nameAtExchange"`

	// Slug corresponds to the JSON schema field "slug".
	Slug string `json:"slug" yaml:"slug" mapstructure:"slug"`

	// SymbolAtExchange corresponds to the JSON schema field "symbolAtExchange".
	SymbolAtExchange string `json:"symbolAtExchange" yaml:"symbolAtExchange" mapstructure:"symbolAtExchange"`
}

type ExchangeFractionalTrading struct {
	// MaxOrderAmount corresponds to the JSON schema field "maxOrderAmount".
	MaxOrderAmount *string `json:"maxOrderAmount,omitempty" yaml:"maxOrderAmount,omitempty" mapstructure:"maxOrderAmount,omitempty"`

	// MaxOrderSize corresponds to the JSON schema field "maxOrderSize".
	MaxOrderSize *string `json:"maxOrderSize,omitempty" yaml:"maxOrderSize,omitempty" mapstructure:"maxOrderSize,omitempty"`

	// MinOrderAmount corresponds to the JSON schema field "minOrderAmount".
	MinOrderAmount *string `json:"minOrderAmount,omitempty" yaml:"minOrderAmount,omitempty" mapstructure:"minOrderAmount,omitempty"`

	// MinOrderSize corresponds to the JSON schema field "minOrderSize".
	MinOrderSize *string `json:"minOrderSize,omitempty" yaml:"minOrderSize,omitempty" mapstructure:"minOrderSize,omitempty"`

	// OrderAmountLimitCurrency corresponds to the JSON schema field
	// "orderAmountLimitCurrency".
	OrderAmountLimitCurrency *string `json:"orderAmountLimitCurrency,omitempty" yaml:"orderAmountLimitCurrency,omitempty" mapstructure:"orderAmountLimitCurrency,omitempty"`

	// StepSize corresponds to the JSON schema field "stepSize".
	StepSize *string `json:"stepSize,omitempty" yaml:"stepSize,omitempty" mapstructure:"stepSize,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Exchange) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["active"]; raw != nil && !ok {
		return fmt.Errorf("field active in Exchange: required")
	}
	if _, ok := raw["nameAtExchange"]; raw != nil && !ok {
		return fmt.Errorf("field nameAtExchange in Exchange: required")
	}
	if _, ok := raw["slug"]; raw != nil && !ok {
		return fmt.Errorf("field slug in Exchange: required")
	}
	if _, ok := raw["symbolAtExchange"]; raw != nil && !ok {
		return fmt.Errorf("field symbolAtExchange in Exchange: required")
	}
	type Plain Exchange
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^[A-Z0-9]{3}$`, string(plain.Slug)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "Slug", `^[A-Z0-9]{3}$`)
	}
	*j = Exchange(plain)
	return nil
}

type InstrumentJson struct {
	// Active corresponds to the JSON schema field "active".
	Active bool `json:"active" yaml:"active" mapstructure:"active"`

	// AlarmsName corresponds to the JSON schema field "alarmsName".
	AlarmsName *string `json:"alarmsName,omitempty" yaml:"alarmsName,omitempty" mapstructure:"alarmsName,omitempty"`

	// Cfi corresponds to the JSON schema field "cfi".
	Cfi *string `json:"cfi,omitempty" yaml:"cfi,omitempty" mapstructure:"cfi,omitempty"`

	// Company corresponds to the JSON schema field "company".
	Company *Company `json:"company,omitempty" yaml:"company,omitempty" mapstructure:"company,omitempty"`

	// Descriptions corresponds to the JSON schema field "descriptions".
	Descriptions *map[string]interface{} `json:"descriptions,omitempty" yaml:"descriptions,omitempty" mapstructure:"descriptions,omitempty"`

	// Dividends corresponds to the JSON schema field "dividends".
	Dividends []interface{} `json:"dividends,omitempty" yaml:"dividends,omitempty" mapstructure:"dividends,omitempty"`

	// ExchangeIds corresponds to the JSON schema field "exchangeIds".
	ExchangeIds []string `json:"exchangeIds" yaml:"exchangeIds" mapstructure:"exchangeIds"`

	// Exchanges corresponds to the JSON schema field "exchanges".
	Exchanges []Exchange `json:"exchanges" yaml:"exchanges" mapstructure:"exchanges"`

	// FundInfo corresponds to the JSON schema field "fundInfo".
	FundInfo *InstrumentJsonFundInfo `json:"fundInfo,omitempty" yaml:"fundInfo,omitempty" mapstructure:"fundInfo,omitempty"`

	// HomeNsin corresponds to the JSON schema field "homeNsin".
	HomeNsin *string `json:"homeNsin,omitempty" yaml:"homeNsin,omitempty" mapstructure:"homeNsin,omitempty"`

	// HomeSymbol corresponds to the JSON schema field "homeSymbol".
	HomeSymbol *string `json:"homeSymbol,omitempty" yaml:"homeSymbol,omitempty" mapstructure:"homeSymbol,omitempty"`

	// IntlSymbol corresponds to the JSON schema field "intlSymbol".
	IntlSymbol *string `json:"intlSymbol,omitempty" yaml:"intlSymbol,omitempty" mapstructure:"intlSymbol,omitempty"`

	// Isin corresponds to the JSON schema field "isin".
	Isin string `json:"isin" yaml:"isin" mapstructure:"isin"`

	// Jurisdictions corresponds to the JSON schema field "jurisdictions".
	Jurisdictions map[string]interface{} `json:"jurisdictions" yaml:"jurisdictions" mapstructure:"jurisdictions"`

	// LegacyTypeChar corresponds to the JSON schema field "legacyTypeChar".
	LegacyTypeChar *string `json:"legacyTypeChar,omitempty" yaml:"legacyTypeChar,omitempty" mapstructure:"legacyTypeChar,omitempty"`

	// LegalTypeId corresponds to the JSON schema field "legalTypeId".
	LegalTypeId string `json:"legalTypeId" yaml:"legalTypeId" mapstructure:"legalTypeId"`

	// MarketCap corresponds to the JSON schema field "marketCap".
	MarketCap *InstrumentJsonMarketCap `json:"marketCap,omitempty" yaml:"marketCap,omitempty" mapstructure:"marketCap,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// NextGenName corresponds to the JSON schema field "nextGenName".
	NextGenName *string `json:"nextGenName,omitempty" yaml:"nextGenName,omitempty" mapstructure:"nextGenName,omitempty"`

	// PriceFactor corresponds to the JSON schema field "priceFactor".
	PriceFactor *int `json:"priceFactor,omitempty" yaml:"priceFactor,omitempty" mapstructure:"priceFactor,omitempty"`

	// ShortName corresponds to the JSON schema field "shortName".
	ShortName *string `json:"shortName,omitempty" yaml:"shortName,omitempty" mapstructure:"shortName,omitempty"`

	// Splits corresponds to the JSON schema field "splits".
	Splits []interface{} `json:"splits,omitempty" yaml:"splits,omitempty" mapstructure:"splits,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// TaxProviderInfo corresponds to the JSON schema field "taxProviderInfo".
	TaxProviderInfo *InstrumentJsonTaxProviderInfo `json:"taxProviderInfo,omitempty" yaml:"taxProviderInfo,omitempty" mapstructure:"taxProviderInfo,omitempty"`

	// TypeId corresponds to the JSON schema field "typeId".
	TypeId InstrumentJsonTypeId `json:"typeId" yaml:"typeId" mapstructure:"typeId"`

	// Wkn corresponds to the JSON schema field "wkn".
	Wkn *string `json:"wkn,omitempty" yaml:"wkn,omitempty" mapstructure:"wkn,omitempty"`
}

type InstrumentJsonFundInfo struct {
	// Category corresponds to the JSON schema field "category".
	Category InstrumentJsonFundInfoCategory `json:"category" yaml:"category" mapstructure:"category"`

	// Currency corresponds to the JSON schema field "currency".
	Currency string `json:"currency" yaml:"currency" mapstructure:"currency"`

	// Domicile corresponds to the JSON schema field "domicile".
	Domicile string `json:"domicile" yaml:"domicile" mapstructure:"domicile"`

	// Index corresponds to the JSON schema field "index".
	Index string `json:"index" yaml:"index" mapstructure:"index"`

	// LaunchDate corresponds to the JSON schema field "launchDate".
	LaunchDate string `json:"launchDate" yaml:"launchDate" mapstructure:"launchDate"`

	// LegalFormType corresponds to the JSON schema field "legalFormType".
	LegalFormType string `json:"legalFormType" yaml:"legalFormType" mapstructure:"legalFormType"`

	// Market corresponds to the JSON schema field "market".
	Market *string `json:"market,omitempty" yaml:"market,omitempty" mapstructure:"market,omitempty"`

	// Method corresponds to the JSON schema field "method".
	Method *string `json:"method,omitempty" yaml:"method,omitempty" mapstructure:"method,omitempty"`

	// Ter corresponds to the JSON schema field "ter".
	Ter string `json:"ter" yaml:"ter" mapstructure:"ter"`

	// Ucits corresponds to the JSON schema field "ucits".
	Ucits bool `json:"ucits" yaml:"ucits" mapstructure:"ucits"`

	// UnderlyingClass corresponds to the JSON schema field "underlyingClass".
	UnderlyingClass string `json:"underlyingClass" yaml:"underlyingClass" mapstructure:"underlyingClass"`

	// UseOfProfits corresponds to the JSON schema field "useOfProfits".
	UseOfProfits string `json:"useOfProfits" yaml:"useOfProfits" mapstructure:"useOfProfits"`

	// UseOfProfitsDisplayName corresponds to the JSON schema field
	// "useOfProfitsDisplayName".
	UseOfProfitsDisplayName string `json:"useOfProfitsDisplayName" yaml:"useOfProfitsDisplayName" mapstructure:"useOfProfitsDisplayName"`
}

type InstrumentJsonFundInfoCategory string

const InstrumentJsonFundInfoCategoryEtf InstrumentJsonFundInfoCategory = "etf"

var enumValues_InstrumentJsonFundInfoCategory = []interface{}{
	"etf",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *InstrumentJsonFundInfoCategory) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_InstrumentJsonFundInfoCategory {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_InstrumentJsonFundInfoCategory, v)
	}
	*j = InstrumentJsonFundInfoCategory(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *InstrumentJsonFundInfo) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["category"]; raw != nil && !ok {
		return fmt.Errorf("field category in InstrumentJsonFundInfo: required")
	}
	if _, ok := raw["currency"]; raw != nil && !ok {
		return fmt.Errorf("field currency in InstrumentJsonFundInfo: required")
	}
	if _, ok := raw["domicile"]; raw != nil && !ok {
		return fmt.Errorf("field domicile in InstrumentJsonFundInfo: required")
	}
	if _, ok := raw["index"]; raw != nil && !ok {
		return fmt.Errorf("field index in InstrumentJsonFundInfo: required")
	}
	if _, ok := raw["launchDate"]; raw != nil && !ok {
		return fmt.Errorf("field launchDate in InstrumentJsonFundInfo: required")
	}
	if _, ok := raw["legalFormType"]; raw != nil && !ok {
		return fmt.Errorf("field legalFormType in InstrumentJsonFundInfo: required")
	}
	if _, ok := raw["ter"]; raw != nil && !ok {
		return fmt.Errorf("field ter in InstrumentJsonFundInfo: required")
	}
	if _, ok := raw["ucits"]; raw != nil && !ok {
		return fmt.Errorf("field ucits in InstrumentJsonFundInfo: required")
	}
	if _, ok := raw["underlyingClass"]; raw != nil && !ok {
		return fmt.Errorf("field underlyingClass in InstrumentJsonFundInfo: required")
	}
	if _, ok := raw["useOfProfits"]; raw != nil && !ok {
		return fmt.Errorf("field useOfProfits in InstrumentJsonFundInfo: required")
	}
	if _, ok := raw["useOfProfitsDisplayName"]; raw != nil && !ok {
		return fmt.Errorf("field useOfProfitsDisplayName in InstrumentJsonFundInfo: required")
	}
	type Plain InstrumentJsonFundInfo
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^[A-Z]{3}$`, string(plain.Currency)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "Currency", `^[A-Z]{3}$`)
	}
	if matched, _ := regexp.MatchString(`^[A-Z]{2}$`, string(plain.Domicile)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "Domicile", `^[A-Z]{2}$`)
	}
	if matched, _ := regexp.MatchString(`^[0-9]{4}-[0-9]{2}-[0-9]{2}$`, string(plain.LaunchDate)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "LaunchDate", `^[0-9]{4}-[0-9]{2}-[0-9]{2}$`)
	}
	if matched, _ := regexp.MatchString(`^[0-9]+\.[0-9]+$`, string(plain.Ter)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "Ter", `^[0-9]+\.[0-9]+$`)
	}
	*j = InstrumentJsonFundInfo(plain)
	return nil
}

type InstrumentJsonMarketCap struct {
	// CurrencyId corresponds to the JSON schema field "currencyId".
	CurrencyId *string `json:"currencyId,omitempty" yaml:"currencyId,omitempty" mapstructure:"currencyId,omitempty"`

	// Value corresponds to the JSON schema field "value".
	Value *string `json:"value,omitempty" yaml:"value,omitempty" mapstructure:"value,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *InstrumentJsonMarketCap) UnmarshalJSON(value []byte) error {
	type Plain InstrumentJsonMarketCap
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.CurrencyId != nil {
		if matched, _ := regexp.MatchString(`^[A-Z]{3}$`, string(*plain.CurrencyId)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "CurrencyId", `^[A-Z]{3}$`)
		}
	}
	if plain.Value != nil {
		if matched, _ := regexp.MatchString(`^[0-9]+\.[0-9]{2}$`, string(*plain.Value)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "Value", `^[0-9]+\.[0-9]{2}$`)
		}
	}
	*j = InstrumentJsonMarketCap(plain)
	return nil
}

type InstrumentJsonTaxProviderInfo struct {
	// Regnology corresponds to the JSON schema field "regnology".
	Regnology *InstrumentJsonTaxProviderInfoRegnology `json:"regnology,omitempty" yaml:"regnology,omitempty" mapstructure:"regnology,omitempty"`

	// Wmdaten corresponds to the JSON schema field "wmdaten".
	Wmdaten *InstrumentJsonTaxProviderInfoWmdaten `json:"wmdaten,omitempty" yaml:"wmdaten,omitempty" mapstructure:"wmdaten,omitempty"`
}

type InstrumentJsonTaxProviderInfoRegnology struct {
	// InstrumentSubType corresponds to the JSON schema field "instrumentSubType".
	InstrumentSubType *int `json:"instrumentSubType,omitempty" yaml:"instrumentSubType,omitempty" mapstructure:"instrumentSubType,omitempty"`

	// InstrumentType corresponds to the JSON schema field "instrumentType".
	InstrumentType *string `json:"instrumentType,omitempty" yaml:"instrumentType,omitempty" mapstructure:"instrumentType,omitempty"`
}

type InstrumentJsonTaxProviderInfoWmdaten struct {
	// BistaIssuerCategory corresponds to the JSON schema field "bistaIssuerCategory".
	BistaIssuerCategory *string `json:"bistaIssuerCategory,omitempty" yaml:"bistaIssuerCategory,omitempty" mapstructure:"bistaIssuerCategory,omitempty"`

	// InstrumentTypeA corresponds to the JSON schema field "instrumentTypeA".
	InstrumentTypeA *string `json:"instrumentTypeA,omitempty" yaml:"instrumentTypeA,omitempty" mapstructure:"instrumentTypeA,omitempty"`

	// InstrumentTypeB corresponds to the JSON schema field "instrumentTypeB".
	InstrumentTypeB *string `json:"instrumentTypeB,omitempty" yaml:"instrumentTypeB,omitempty" mapstructure:"instrumentTypeB,omitempty"`

	// InstrumentTypeC corresponds to the JSON schema field "instrumentTypeC".
	InstrumentTypeC *string `json:"instrumentTypeC,omitempty" yaml:"instrumentTypeC,omitempty" mapstructure:"instrumentTypeC,omitempty"`

	// InstrumentTypeD corresponds to the JSON schema field "instrumentTypeD".
	InstrumentTypeD *string `json:"instrumentTypeD,omitempty" yaml:"instrumentTypeD,omitempty" mapstructure:"instrumentTypeD,omitempty"`

	// InstrumentTypeE corresponds to the JSON schema field "instrumentTypeE".
	InstrumentTypeE *string `json:"instrumentTypeE,omitempty" yaml:"instrumentTypeE,omitempty" mapstructure:"instrumentTypeE,omitempty"`

	// InstrumentTypeF corresponds to the JSON schema field "instrumentTypeF".
	InstrumentTypeF *string `json:"instrumentTypeF,omitempty" yaml:"instrumentTypeF,omitempty" mapstructure:"instrumentTypeF,omitempty"`
}

type InstrumentJsonTypeId string

const InstrumentJsonTypeIdCrypto InstrumentJsonTypeId = "crypto"
const InstrumentJsonTypeIdEtf InstrumentJsonTypeId = "etf"
const InstrumentJsonTypeIdFund InstrumentJsonTypeId = "fund"
const InstrumentJsonTypeIdStock InstrumentJsonTypeId = "stock"

var enumValues_InstrumentJsonTypeId = []interface{}{
	"crypto",
	"fund",
	"stock",
	"etf",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *InstrumentJsonTypeId) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_InstrumentJsonTypeId {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_InstrumentJsonTypeId, v)
	}
	*j = InstrumentJsonTypeId(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *InstrumentJson) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["active"]; raw != nil && !ok {
		return fmt.Errorf("field active in InstrumentJson: required")
	}
	if _, ok := raw["exchangeIds"]; raw != nil && !ok {
		return fmt.Errorf("field exchangeIds in InstrumentJson: required")
	}
	if _, ok := raw["exchanges"]; raw != nil && !ok {
		return fmt.Errorf("field exchanges in InstrumentJson: required")
	}
	if _, ok := raw["isin"]; raw != nil && !ok {
		return fmt.Errorf("field isin in InstrumentJson: required")
	}
	if _, ok := raw["jurisdictions"]; raw != nil && !ok {
		return fmt.Errorf("field jurisdictions in InstrumentJson: required")
	}
	if _, ok := raw["legalTypeId"]; raw != nil && !ok {
		return fmt.Errorf("field legalTypeId in InstrumentJson: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in InstrumentJson: required")
	}
	if _, ok := raw["typeId"]; raw != nil && !ok {
		return fmt.Errorf("field typeId in InstrumentJson: required")
	}
	type Plain InstrumentJson
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.Cfi != nil {
		if matched, _ := regexp.MatchString(`^[A-Z]{6}$`, string(*plain.Cfi)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "Cfi", `^[A-Z]{6}$`)
		}
	}
	*j = InstrumentJson(plain)
	return nil
}

type Jurisdiction struct {
	// Active corresponds to the JSON schema field "active".
	Active bool `json:"active" yaml:"active" mapstructure:"active"`

	// FractionalTradingAllowed corresponds to the JSON schema field
	// "fractionalTradingAllowed".
	FractionalTradingAllowed *bool `json:"fractionalTradingAllowed,omitempty" yaml:"fractionalTradingAllowed,omitempty" mapstructure:"fractionalTradingAllowed,omitempty"`

	// KidLink corresponds to the JSON schema field "kidLink".
	KidLink *string `json:"kidLink,omitempty" yaml:"kidLink,omitempty" mapstructure:"kidLink,omitempty"`

	// KidRequired corresponds to the JSON schema field "kidRequired".
	KidRequired bool `json:"kidRequired" yaml:"kidRequired" mapstructure:"kidRequired"`

	// ProprietaryTradable corresponds to the JSON schema field "proprietaryTradable".
	ProprietaryTradable *bool `json:"proprietaryTradable,omitempty" yaml:"proprietaryTradable,omitempty" mapstructure:"proprietaryTradable,omitempty"`

	// Savable corresponds to the JSON schema field "savable".
	Savable bool `json:"savable" yaml:"savable" mapstructure:"savable"`

	// UsesWeightsForExchanges corresponds to the JSON schema field
	// "usesWeightsForExchanges".
	UsesWeightsForExchanges *bool `json:"usesWeightsForExchanges,omitempty" yaml:"usesWeightsForExchanges,omitempty" mapstructure:"usesWeightsForExchanges,omitempty"`

	// Weights corresponds to the JSON schema field "weights".
	Weights *map[string]interface{} `json:"weights,omitempty" yaml:"weights,omitempty" mapstructure:"weights,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Jurisdiction) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["active"]; raw != nil && !ok {
		return fmt.Errorf("field active in Jurisdiction: required")
	}
	if _, ok := raw["kidRequired"]; raw != nil && !ok {
		return fmt.Errorf("field kidRequired in Jurisdiction: required")
	}
	if _, ok := raw["savable"]; raw != nil && !ok {
		return fmt.Errorf("field savable in Jurisdiction: required")
	}
	type Plain Jurisdiction
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.KidLink != nil {
		if matched, _ := regexp.MatchString(`^https://.*\.pdf\?.*$`, string(*plain.KidLink)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "KidLink", `^https://.*\.pdf\?.*$`)
		}
	}
	*j = Jurisdiction(plain)
	return nil
}

type Tag struct {
	// Icon corresponds to the JSON schema field "icon".
	Icon string `json:"icon" yaml:"icon" mapstructure:"icon"`

	// Id corresponds to the JSON schema field "id".
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Tag) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["icon"]; raw != nil && !ok {
		return fmt.Errorf("field icon in Tag: required")
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in Tag: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in Tag: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in Tag: required")
	}
	type Plain Tag
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^https://.*\.png$`, string(plain.Icon)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "Icon", `^https://.*\.png$`)
	}
	*j = Tag(plain)
	return nil
}

type TargetMarket struct {
	// InvestorExperience corresponds to the JSON schema field "investorExperience".
	InvestorExperience TargetMarketInvestorExperience `json:"investorExperience" yaml:"investorExperience" mapstructure:"investorExperience"`

	// InvestorType corresponds to the JSON schema field "investorType".
	InvestorType TargetMarketInvestorType `json:"investorType" yaml:"investorType" mapstructure:"investorType"`
}

type TargetMarketInvestorExperience string

const TargetMarketInvestorExperienceAdvancedKnowledge TargetMarketInvestorExperience = "advancedKnowledge"
const TargetMarketInvestorExperienceBasicKnowledge TargetMarketInvestorExperience = "basicKnowledge"
const TargetMarketInvestorExperienceExpertKnowledge TargetMarketInvestorExperience = "expertKnowledge"
const TargetMarketInvestorExperienceInformedKnowledge TargetMarketInvestorExperience = "informedKnowledge"
const TargetMarketInvestorExperienceIntermediateKnowledge TargetMarketInvestorExperience = "intermediateKnowledge"

var enumValues_TargetMarketInvestorExperience = []interface{}{
	"basicKnowledge",
	"informedKnowledge",
	"advancedKnowledge",
	"intermediateKnowledge",
	"expertKnowledge",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TargetMarketInvestorExperience) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TargetMarketInvestorExperience {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TargetMarketInvestorExperience, v)
	}
	*j = TargetMarketInvestorExperience(v)
	return nil
}

type TargetMarketInvestorType string

const TargetMarketInvestorTypeEligible TargetMarketInvestorType = "eligible"
const TargetMarketInvestorTypeProfessional TargetMarketInvestorType = "professional"
const TargetMarketInvestorTypeRetail TargetMarketInvestorType = "retail"

var enumValues_TargetMarketInvestorType = []interface{}{
	"retail",
	"professional",
	"eligible",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TargetMarketInvestorType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TargetMarketInvestorType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TargetMarketInvestorType, v)
	}
	*j = TargetMarketInvestorType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TargetMarket) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["investorExperience"]; raw != nil && !ok {
		return fmt.Errorf("field investorExperience in TargetMarket: required")
	}
	if _, ok := raw["investorType"]; raw != nil && !ok {
		return fmt.Errorf("field investorType in TargetMarket: required")
	}
	type Plain TargetMarket
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = TargetMarket(plain)
	return nil
}
